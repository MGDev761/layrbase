{"ast":null,"code":"import { supabase } from '../lib/supabase';\n\n// Shareholders\nexport const capTableService = {\n  // Shareholders\n  async getShareholders() {\n    const {\n      data,\n      error\n    } = await supabase.from('shareholders').select('*').order('name');\n    if (error) throw error;\n    return data;\n  },\n  async createShareholder(shareholder) {\n    const {\n      data,\n      error\n    } = await supabase.from('shareholders').insert([shareholder]).select().single();\n    if (error) throw error;\n    return data;\n  },\n  async updateShareholder(id, updates) {\n    const {\n      data,\n      error\n    } = await supabase.from('shareholders').update(updates).eq('id', id).select().single();\n    if (error) throw error;\n    return data;\n  },\n  async deleteShareholder(id) {\n    const {\n      error\n    } = await supabase.from('shareholders').delete().eq('id', id);\n    if (error) throw error;\n  },\n  // Share Classes\n  async getShareClasses() {\n    const {\n      data,\n      error\n    } = await supabase.from('share_classes').select('*').order('name');\n    if (error) throw error;\n    return data;\n  },\n  async createShareClass(shareClass) {\n    const {\n      data,\n      error\n    } = await supabase.from('share_classes').insert([shareClass]).select().single();\n    if (error) throw error;\n    return data;\n  },\n  // Financing Rounds\n  async getFinancingRounds() {\n    const {\n      data,\n      error\n    } = await supabase.from('financing_rounds').select(`\n        *,\n        share_classes(name)\n      `).order('date', {\n      ascending: false\n    });\n    if (error) throw error;\n    return data;\n  },\n  async createFinancingRound(round) {\n    const {\n      data,\n      error\n    } = await supabase.from('financing_rounds').insert([round]).select().single();\n    if (error) throw error;\n    return data;\n  },\n  async updateFinancingRound(id, updates) {\n    const {\n      data,\n      error\n    } = await supabase.from('financing_rounds').update(updates).eq('id', id).select().single();\n    if (error) throw error;\n    return data;\n  },\n  // Transactions\n  async getTransactions(roundId = null) {\n    try {\n      let query = supabase.from('transactions').select(`\n          *,\n          shareholders(name, role),\n          financing_rounds(name, date)\n        `).order('created_at');\n      if (roundId) {\n        query = query.eq('round_id', roundId);\n      }\n      const {\n        data,\n        error\n      } = await query;\n      if (error) throw error;\n\n      // Fetch share classes separately if needed\n      if (data && data.length > 0) {\n        const roundIds = [...new Set(data.map(tx => tx.round_id).filter(Boolean))];\n        if (roundIds.length > 0) {\n          const {\n            data: roundsData\n          } = await supabase.from('financing_rounds').select('id, share_classes(name)').in('id', roundIds);\n          const roundMap = {};\n          roundsData === null || roundsData === void 0 ? void 0 : roundsData.forEach(round => {\n            var _round$share_classes;\n            roundMap[round.id] = ((_round$share_classes = round.share_classes) === null || _round$share_classes === void 0 ? void 0 : _round$share_classes.name) || 'Common';\n          });\n\n          // Add share class to transactions\n          data.forEach(tx => {\n            tx.shareClass = roundMap[tx.round_id] || 'Common';\n          });\n        }\n      }\n      return data || [];\n    } catch (error) {\n      console.error('Error in getTransactions:', error);\n      throw error;\n    }\n  },\n  async createTransaction(transaction) {\n    const {\n      data,\n      error\n    } = await supabase.from('transactions').insert([transaction]).select().single();\n    if (error) throw error;\n    return data;\n  },\n  async updateTransaction(id, updates) {\n    const {\n      data,\n      error\n    } = await supabase.from('transactions').update(updates).eq('id', id).select().single();\n    if (error) throw error;\n    return data;\n  },\n  async deleteTransaction(id) {\n    const {\n      error\n    } = await supabase.from('transactions').delete().eq('id', id);\n    if (error) throw error;\n  },\n  // Preference Terms\n  async getPreferenceTerms() {\n    const {\n      data,\n      error\n    } = await supabase.from('preference_terms').select(`\n        *,\n        share_classes(name)\n      `);\n    if (error) throw error;\n    return data;\n  },\n  async createPreferenceTerm(term) {\n    const {\n      data,\n      error\n    } = await supabase.from('preference_terms').insert([term]).select().single();\n    if (error) throw error;\n    return data;\n  },\n  // Cap Table Calculations\n  async getCapTableAtRound(roundId = null) {\n    try {\n      // Get all transactions up to the specified round\n      let query = supabase.from('transactions').select(`\n          *,\n          shareholders(name, role),\n          financing_rounds(name, date)\n        `).order('created_at');\n      if (roundId) {\n        // Get the round date to filter transactions\n        const {\n          data: roundData,\n          error: roundError\n        } = await supabase.from('financing_rounds').select('date').eq('id', roundId).single();\n        if (roundError) throw roundError;\n        if (roundData) {\n          query = query.lte('financing_rounds.date', roundData.date);\n        }\n      }\n      const {\n        data: transactions,\n        error\n      } = await query;\n      if (error) throw error;\n\n      // Fetch share classes separately\n      if (transactions && transactions.length > 0) {\n        const roundIds = [...new Set(transactions.map(tx => tx.round_id).filter(Boolean))];\n        if (roundIds.length > 0) {\n          const {\n            data: roundsData\n          } = await supabase.from('financing_rounds').select('id, share_classes(name)').in('id', roundIds);\n          const roundMap = {};\n          roundsData === null || roundsData === void 0 ? void 0 : roundsData.forEach(round => {\n            var _round$share_classes2;\n            roundMap[round.id] = ((_round$share_classes2 = round.share_classes) === null || _round$share_classes2 === void 0 ? void 0 : _round$share_classes2.name) || 'Common';\n          });\n\n          // Add share class to transactions\n          transactions.forEach(tx => {\n            tx.shareClass = roundMap[tx.round_id] || 'Common';\n          });\n        }\n      }\n\n      // Calculate cap table from transactions\n      return this.calculateCapTableFromTransactions(transactions || []);\n    } catch (error) {\n      console.error('Error in getCapTableAtRound:', error);\n      throw error;\n    }\n  },\n  calculateCapTableFromTransactions(transactions) {\n    const holdings = {};\n    let totalShares = 0;\n\n    // Aggregate shares by shareholder\n    transactions.forEach(tx => {\n      const shareholderId = tx.shareholder_id;\n      if (!holdings[shareholderId]) {\n        var _tx$shareholders, _tx$shareholders2, _tx$financing_rounds, _tx$financing_rounds$;\n        holdings[shareholderId] = {\n          id: shareholderId,\n          name: ((_tx$shareholders = tx.shareholders) === null || _tx$shareholders === void 0 ? void 0 : _tx$shareholders.name) || 'Unknown',\n          role: ((_tx$shareholders2 = tx.shareholders) === null || _tx$shareholders2 === void 0 ? void 0 : _tx$shareholders2.role) || 'Unknown',\n          shares: 0,\n          investment: 0,\n          shareClass: ((_tx$financing_rounds = tx.financing_rounds) === null || _tx$financing_rounds === void 0 ? void 0 : (_tx$financing_rounds$ = _tx$financing_rounds.share_classes) === null || _tx$financing_rounds$ === void 0 ? void 0 : _tx$financing_rounds$.name) || 'Common'\n        };\n      }\n      holdings[shareholderId].shares += parseFloat(tx.shares_issued || 0);\n      holdings[shareholderId].investment += parseFloat(tx.investment_amount || 0);\n      totalShares += parseFloat(tx.shares_issued || 0);\n    });\n\n    // Calculate ownership percentages\n    const capTable = Object.values(holdings).map(holding => ({\n      ...holding,\n      ownership: totalShares > 0 ? holding.shares / totalShares * 100 : 0\n    }));\n    return {\n      capTable,\n      totalShares,\n      summary: {\n        totalShares,\n        totalInvestment: capTable.reduce((sum, h) => sum + h.investment, 0)\n      }\n    };\n  },\n  // Exit Scenario Calculations\n  async calculateExitScenario(acquisitionAmount, acquisitionPercentage, preferenceType = 'non-participating') {\n    const {\n      capTable\n    } = await this.getCapTableAtRound();\n    const actualAcquisitionValue = acquisitionAmount * acquisitionPercentage / 100;\n\n    // Get preference terms\n    const preferenceTerms = await this.getPreferenceTerms();\n    return this.calculateExitValues(capTable, actualAcquisitionValue, preferenceTerms, preferenceType);\n  },\n  calculateExitValues(capTable, acquisitionValue, preferenceTerms, preferenceType) {\n    // Calculate preference payouts\n    const preferencePayouts = capTable.filter(shareholder => shareholder.shareClass.includes('Preferred')).map(shareholder => {\n      const term = preferenceTerms.find(t => t.share_classes.name === shareholder.shareClass);\n      const multiplier = term ? term.multiplier : 1;\n      const preferenceAmount = shareholder.investment * multiplier;\n      const conversionValue = shareholder.ownership / 100 * acquisitionValue;\n      let finalValue;\n      if (preferenceType === 'non-participating') {\n        finalValue = Math.max(preferenceAmount, conversionValue);\n      } else {\n        finalValue = preferenceAmount + conversionValue;\n      }\n      return {\n        ...shareholder,\n        preferenceAmount,\n        conversionValue,\n        finalValue,\n        tookPreference: preferenceType === 'participating' || preferenceAmount > conversionValue,\n        multiplier\n      };\n    });\n\n    // Calculate remaining proceeds\n    const totalPreferencePayout = preferencePayouts.reduce((sum, p) => sum + p.finalValue, 0);\n    const remainingProceeds = Math.max(0, acquisitionValue - totalPreferencePayout);\n\n    // Distribute remaining to common shareholders\n    const commonShareholders = capTable.filter(s => s.shareClass === 'Common');\n    const totalCommonOwnership = commonShareholders.reduce((sum, s) => sum + s.ownership, 0);\n    const exitCalculations = capTable.map(shareholder => {\n      if (shareholder.shareClass.includes('Preferred')) {\n        const preferencePayout = preferencePayouts.find(p => p.id === shareholder.id);\n        return preferencePayout;\n      } else {\n        const commonShare = totalCommonOwnership > 0 ? shareholder.ownership / totalCommonOwnership * remainingProceeds : 0;\n        return {\n          ...shareholder,\n          preferenceAmount: 0,\n          conversionValue: commonShare,\n          finalValue: commonShare,\n          tookPreference: false,\n          multiplier: 1\n        };\n      }\n    });\n    return {\n      exitCalculations,\n      totalExitValue: exitCalculations.reduce((sum, calc) => sum + calc.finalValue, 0),\n      totalPreferencePayout,\n      remainingProceeds\n    };\n  }\n};","map":{"version":3,"names":["supabase","capTableService","getShareholders","data","error","from","select","order","createShareholder","shareholder","insert","single","updateShareholder","id","updates","update","eq","deleteShareholder","delete","getShareClasses","createShareClass","shareClass","getFinancingRounds","ascending","createFinancingRound","round","updateFinancingRound","getTransactions","roundId","query","length","roundIds","Set","map","tx","round_id","filter","Boolean","roundsData","in","roundMap","forEach","_round$share_classes","share_classes","name","console","createTransaction","transaction","updateTransaction","deleteTransaction","getPreferenceTerms","createPreferenceTerm","term","getCapTableAtRound","roundData","roundError","lte","date","transactions","_round$share_classes2","calculateCapTableFromTransactions","holdings","totalShares","shareholderId","shareholder_id","_tx$shareholders","_tx$shareholders2","_tx$financing_rounds","_tx$financing_rounds$","shareholders","role","shares","investment","financing_rounds","parseFloat","shares_issued","investment_amount","capTable","Object","values","holding","ownership","summary","totalInvestment","reduce","sum","h","calculateExitScenario","acquisitionAmount","acquisitionPercentage","preferenceType","actualAcquisitionValue","preferenceTerms","calculateExitValues","acquisitionValue","preferencePayouts","includes","find","t","multiplier","preferenceAmount","conversionValue","finalValue","Math","max","tookPreference","totalPreferencePayout","p","remainingProceeds","commonShareholders","s","totalCommonOwnership","exitCalculations","preferencePayout","commonShare","totalExitValue","calc"],"sources":["/Users/markgiblin/Desktop/layrbase/src/services/capTableService.js"],"sourcesContent":["import { supabase } from '../lib/supabase';\n\n// Shareholders\nexport const capTableService = {\n  // Shareholders\n  async getShareholders() {\n    const { data, error } = await supabase\n      .from('shareholders')\n      .select('*')\n      .order('name');\n    \n    if (error) throw error;\n    return data;\n  },\n\n  async createShareholder(shareholder) {\n    const { data, error } = await supabase\n      .from('shareholders')\n      .insert([shareholder])\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  async updateShareholder(id, updates) {\n    const { data, error } = await supabase\n      .from('shareholders')\n      .update(updates)\n      .eq('id', id)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  async deleteShareholder(id) {\n    const { error } = await supabase\n      .from('shareholders')\n      .delete()\n      .eq('id', id);\n    \n    if (error) throw error;\n  },\n\n  // Share Classes\n  async getShareClasses() {\n    const { data, error } = await supabase\n      .from('share_classes')\n      .select('*')\n      .order('name');\n    \n    if (error) throw error;\n    return data;\n  },\n\n  async createShareClass(shareClass) {\n    const { data, error } = await supabase\n      .from('share_classes')\n      .insert([shareClass])\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Financing Rounds\n  async getFinancingRounds() {\n    const { data, error } = await supabase\n      .from('financing_rounds')\n      .select(`\n        *,\n        share_classes(name)\n      `)\n      .order('date', { ascending: false });\n    \n    if (error) throw error;\n    return data;\n  },\n\n  async createFinancingRound(round) {\n    const { data, error } = await supabase\n      .from('financing_rounds')\n      .insert([round])\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  async updateFinancingRound(id, updates) {\n    const { data, error } = await supabase\n      .from('financing_rounds')\n      .update(updates)\n      .eq('id', id)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Transactions\n  async getTransactions(roundId = null) {\n    try {\n      let query = supabase\n        .from('transactions')\n        .select(`\n          *,\n          shareholders(name, role),\n          financing_rounds(name, date)\n        `)\n        .order('created_at');\n      \n      if (roundId) {\n        query = query.eq('round_id', roundId);\n      }\n      \n      const { data, error } = await query;\n      if (error) throw error;\n      \n      // Fetch share classes separately if needed\n      if (data && data.length > 0) {\n        const roundIds = [...new Set(data.map(tx => tx.round_id).filter(Boolean))];\n        if (roundIds.length > 0) {\n          const { data: roundsData } = await supabase\n            .from('financing_rounds')\n            .select('id, share_classes(name)')\n            .in('id', roundIds);\n          \n          const roundMap = {};\n          roundsData?.forEach(round => {\n            roundMap[round.id] = round.share_classes?.name || 'Common';\n          });\n          \n          // Add share class to transactions\n          data.forEach(tx => {\n            tx.shareClass = roundMap[tx.round_id] || 'Common';\n          });\n        }\n      }\n      \n      return data || [];\n    } catch (error) {\n      console.error('Error in getTransactions:', error);\n      throw error;\n    }\n  },\n\n  async createTransaction(transaction) {\n    const { data, error } = await supabase\n      .from('transactions')\n      .insert([transaction])\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  async updateTransaction(id, updates) {\n    const { data, error } = await supabase\n      .from('transactions')\n      .update(updates)\n      .eq('id', id)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  async deleteTransaction(id) {\n    const { error } = await supabase\n      .from('transactions')\n      .delete()\n      .eq('id', id);\n    \n    if (error) throw error;\n  },\n\n  // Preference Terms\n  async getPreferenceTerms() {\n    const { data, error } = await supabase\n      .from('preference_terms')\n      .select(`\n        *,\n        share_classes(name)\n      `);\n    \n    if (error) throw error;\n    return data;\n  },\n\n  async createPreferenceTerm(term) {\n    const { data, error } = await supabase\n      .from('preference_terms')\n      .insert([term])\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return data;\n  },\n\n  // Cap Table Calculations\n  async getCapTableAtRound(roundId = null) {\n    try {\n      // Get all transactions up to the specified round\n      let query = supabase\n        .from('transactions')\n        .select(`\n          *,\n          shareholders(name, role),\n          financing_rounds(name, date)\n        `)\n        .order('created_at');\n      \n      if (roundId) {\n        // Get the round date to filter transactions\n        const { data: roundData, error: roundError } = await supabase\n          .from('financing_rounds')\n          .select('date')\n          .eq('id', roundId)\n          .single();\n        \n        if (roundError) throw roundError;\n        \n        if (roundData) {\n          query = query.lte('financing_rounds.date', roundData.date);\n        }\n      }\n      \n      const { data: transactions, error } = await query;\n      if (error) throw error;\n\n      // Fetch share classes separately\n      if (transactions && transactions.length > 0) {\n        const roundIds = [...new Set(transactions.map(tx => tx.round_id).filter(Boolean))];\n        if (roundIds.length > 0) {\n          const { data: roundsData } = await supabase\n            .from('financing_rounds')\n            .select('id, share_classes(name)')\n            .in('id', roundIds);\n          \n          const roundMap = {};\n          roundsData?.forEach(round => {\n            roundMap[round.id] = round.share_classes?.name || 'Common';\n          });\n          \n          // Add share class to transactions\n          transactions.forEach(tx => {\n            tx.shareClass = roundMap[tx.round_id] || 'Common';\n          });\n        }\n      }\n\n      // Calculate cap table from transactions\n      return this.calculateCapTableFromTransactions(transactions || []);\n    } catch (error) {\n      console.error('Error in getCapTableAtRound:', error);\n      throw error;\n    }\n  },\n\n  calculateCapTableFromTransactions(transactions) {\n    const holdings = {};\n    let totalShares = 0;\n\n    // Aggregate shares by shareholder\n    transactions.forEach(tx => {\n      const shareholderId = tx.shareholder_id;\n      if (!holdings[shareholderId]) {\n        holdings[shareholderId] = {\n          id: shareholderId,\n          name: tx.shareholders?.name || 'Unknown',\n          role: tx.shareholders?.role || 'Unknown',\n          shares: 0,\n          investment: 0,\n          shareClass: tx.financing_rounds?.share_classes?.name || 'Common',\n        };\n      }\n      \n      holdings[shareholderId].shares += parseFloat(tx.shares_issued || 0);\n      holdings[shareholderId].investment += parseFloat(tx.investment_amount || 0);\n      totalShares += parseFloat(tx.shares_issued || 0);\n    });\n\n    // Calculate ownership percentages\n    const capTable = Object.values(holdings).map(holding => ({\n      ...holding,\n      ownership: totalShares > 0 ? (holding.shares / totalShares) * 100 : 0,\n    }));\n\n    return {\n      capTable,\n      totalShares,\n      summary: {\n        totalShares,\n        totalInvestment: capTable.reduce((sum, h) => sum + h.investment, 0),\n      }\n    };\n  },\n\n  // Exit Scenario Calculations\n  async calculateExitScenario(acquisitionAmount, acquisitionPercentage, preferenceType = 'non-participating') {\n    const { capTable } = await this.getCapTableAtRound();\n    const actualAcquisitionValue = (acquisitionAmount * acquisitionPercentage) / 100;\n    \n    // Get preference terms\n    const preferenceTerms = await this.getPreferenceTerms();\n    \n    return this.calculateExitValues(capTable, actualAcquisitionValue, preferenceTerms, preferenceType);\n  },\n\n  calculateExitValues(capTable, acquisitionValue, preferenceTerms, preferenceType) {\n    // Calculate preference payouts\n    const preferencePayouts = capTable\n      .filter(shareholder => shareholder.shareClass.includes('Preferred'))\n      .map(shareholder => {\n        const term = preferenceTerms.find(t => t.share_classes.name === shareholder.shareClass);\n        const multiplier = term ? term.multiplier : 1;\n        const preferenceAmount = shareholder.investment * multiplier;\n        const conversionValue = (shareholder.ownership / 100) * acquisitionValue;\n        \n        let finalValue;\n        if (preferenceType === 'non-participating') {\n          finalValue = Math.max(preferenceAmount, conversionValue);\n        } else {\n          finalValue = preferenceAmount + conversionValue;\n        }\n\n        return {\n          ...shareholder,\n          preferenceAmount,\n          conversionValue,\n          finalValue,\n          tookPreference: preferenceType === 'participating' || preferenceAmount > conversionValue,\n          multiplier,\n        };\n      });\n\n    // Calculate remaining proceeds\n    const totalPreferencePayout = preferencePayouts.reduce((sum, p) => sum + p.finalValue, 0);\n    const remainingProceeds = Math.max(0, acquisitionValue - totalPreferencePayout);\n\n    // Distribute remaining to common shareholders\n    const commonShareholders = capTable.filter(s => s.shareClass === 'Common');\n    const totalCommonOwnership = commonShareholders.reduce((sum, s) => sum + s.ownership, 0);\n\n    const exitCalculations = capTable.map(shareholder => {\n      if (shareholder.shareClass.includes('Preferred')) {\n        const preferencePayout = preferencePayouts.find(p => p.id === shareholder.id);\n        return preferencePayout;\n      } else {\n        const commonShare = totalCommonOwnership > 0 ? (shareholder.ownership / totalCommonOwnership) * remainingProceeds : 0;\n        return {\n          ...shareholder,\n          preferenceAmount: 0,\n          conversionValue: commonShare,\n          finalValue: commonShare,\n          tookPreference: false,\n          multiplier: 1,\n        };\n      }\n    });\n\n    return {\n      exitCalculations,\n      totalExitValue: exitCalculations.reduce((sum, calc) => sum + calc.finalValue, 0),\n      totalPreferencePayout,\n      remainingProceeds,\n    };\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}